# 简单的笔记



##第四章

###变量

基本数据类型的复制是值的复制，也就是创建毫不关联的新副本
引用类型的复制是指针的复制，也会复制一份到新变量分配的空间中，也就是前后两个对象指向堆中同一个地址
函数参数是值的传递

关于变量类型的检测：
基本数据类型 typeof
引用类型  instanceof

###执行环境与作用域

js中一个非常重要的概念，就是执行环境。在该环境中，有一个与之关联的*变量对象*。这个环境下的变量与函数与这个对象有着密切的联系。

最外层的是全局作用函数
每个函数都有自己的执行环境

当进入一个执行环境中，会被推入一个环境栈，而在离开一执行环境后，会被推出环境栈，会脱离原来的当前活动变量

当代码在执行环境中执行时，会产生一个作用域链，有了作用域链，变量函数可以更加有序。而这个作用域链的前端永远指向当前环境对象，向外一层就是外部一层的函数，最顶层会达到全局作用对象。

所以

####延长作用域链

try-catch的catch块

with

####没有块级作用域

js不像类c语言，在花括号内外没有块级作用域之说
比如说if for

### 垃圾收集机制
垃圾自动收集机制
也就是定时找出不需要的可以回收的内存空间

当然需要确认该变量是否有用

1.标记清除


## 第五章 引用类型
### 1 object类型
那么我们可以用定义字面量的方式创建对象，同时，这种方式还适用于向函数传递多个参数，访问时用args.xxx

### 2 Array类型
那么这个类型的特点是，它数组里面每个元素都能保存任何类型的数据
而且数组的大小不是固定的，而是可以动态调整的
length属性不只是只读的，它还可以移除超出长度的项或者添加新项
isArray()方法检测是否为数组，解决了不同执行环境的问题

join方法可以获得不同分隔符分隔的字符串
**栈方法**

有个类似栈操作的数组方法，也就是类似于推栈出栈
push 和 pop
但是因为是栈方法，所以是先进后出，可操作的也就只有栈的顶层

push方法返回数组现在的长度，传入推进的参数，pop方法返回移除项

**队列方法**
先进先出，提供了shift和unshift方法 ，shift可以在数组的首端移除项，unshift可以在数组首端添加项
**排序方法**
reverse方法，实现倒序，但这个方法功能比较局限
sort方法，将每一项都先用tostring方法转换成字符串，然后可以接收一个参数函数，这个参数函数指定了如何进行排序的方法

concat方法可以基于现有项创建新的数组，类似于将传入的数组等一个一个拆分，并组合在原数组上
slice方法可以基于现有数组创建新的数组，就是截取数组中一部分，第几项到第几项

最强大的是splice方法

**迭代方法**
参数也是一个运行函数，以及一个可选的。？
具体有需要再查询

### 3 Rexpe类型


### 4 Function类型
众所周知，js函数皆对象，且函数名就是指向函数的指针

**声明方式**
函数表达式和函数声明
当然解析器会提前读取函数声明，然后在其他代码执行前，也就是函数声明提升

**没有重载**
其中一方面是由于其参数列表，事实上是默认列表，所以无法识别确认它的参数个数，另一个方面，函数名实质上就是一个指向函数对象的指针，所以它就像一个变量，被重复的赋值实质上也是指向同一个函数，尽管它们在不同的环境之下

**为值**
可以像变量一样返回，如果不加括号，函数就不会执行
如果将函数名称赋值，那么相当于一个指针指向了

**函数内部属性**

argument和this

callee属性指向拥有这个对象的函数
this指向当前执行的环境对象

*函数属性和方法*
apply和call方法，实质上都是在环境中调用函数对象
也可以理解成扩充作用域，对象与函数也不需要有任何的耦合关系

```
window.color = "red";
var o;
o.color = "blue";
function aa(){
  alert(this.color);
}

//如果我们想通过o调用这个函数
//法1

o.saycolor = aa();
//法2
aa.call(o);
```


### 基本包装类型
一种特殊的引用类型

boolean number string

最主要的区别是变量的生存期
普通的引用类型在离开当前作用域之前一直存在，而基本包装类型所创建的对象在执行第一行代码的时候就被销毁了

**单体内置对象**
不需要实例化，就可以使用的对象'



##第六章

对象的创建
工厂模式
构造函数模式：可以将实例标示为一种特定的对象


